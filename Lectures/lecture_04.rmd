---
title: "R crash course / 04"
author: ""
date: "`r Sys.Date()`"
output:
  ioslides_presentation: 
    widescreen: true
    smaller: true
    css: files/style.css
    logo: files/logo_bihealth_en.png
---

```{r,echo=FALSE}
## Set default options for the knitr RMD processing
knitr::opts_chunk$set(echo=TRUE,eval=FALSE,warning=FALSE,message=FALSE,fig.width=5,fig.height=5,cache=FALSE,autodep=TRUE, results="hide")
library(readxl)
library(beeswarm)
library(tidyr)
library(vioplot)
library(sm)
library(zoo)
library(RColorBrewer)
```

# Creating the LABRES data set

## Labres data set

The following slides are for your reference only. You can trace how I
created the `labwide` data frame using meta-data from
`expression_data_vaccination_example.xlsx` and `labresults_full.csv` data
files. 

The data set contains laboratory measurements for several parameters (such
as white blood cell count or C-reactive protein) for vaccinees vaccinated
with either Fluad (adjuvant-containing influenza vaccine), Agrippal (same,
but without adjuvant) or placebo, for several days before and after
vaccination.

## Reading and column selection

```{r,eval=TRUE}
targets <- read_xlsx("Datasets/expression_data_vaccination_example.xlsx", 
  sheet=1)
targets <- targets[ , c("USUBJID", "Timepoint", "ARM", "SEX", "AGE") ]
lab <- read.csv("Datasets/labresults_full.csv")
lab <- lab[ , 
  c("USUBJID", "LBTEST", "LBTESTCD", "LBORRES", "Timepoint") ]

## remove the "SCREEN" time point
lab <- lab[ lab$Timepoint != "SCREEN", ]

## not what we want!
merged <- merge(targets, lab, by="USUBJID")
table(merged$Timepoint.x, merged$Timepoint.y)
```

## Reading and column selection

We need to choose: do we want to keep all measurements and just fill out
meta-information from `targets`, or do we want only to keep the time points
present in the expression data set?

```{r,eval=TRUE}
## to keep all time points
targets2 <- targets[ , c("USUBJID", "ARM", "SEX", "AGE") ]

## remove duplicated lines
targets2 <- targets2[ !duplicated(targets2$USUBJID), ] 

## merge
merged_full <- merge(targets2, lab, by="USUBJID")

## this one drops all timepoints not present in "targets"
merged <- merge(targets, lab, by=c("USUBJID", "Timepoint"))
```

## Converting to wide format

```{r}
## this does not work as expected, because "LBTESTCD" 
## and "LBTEST" contain the same information – we cannot 
## store both in the column names

labwide <- spread(merged, key="LBTESTCD", value="LBORRES")
```

```{r eval=TRUE}
## this works
labwide <- spread(merged[ , colnames(merged) != "LBTEST"], key="LBTESTCD", value="LBORRES")
```

## Cleaning up

```{r,eval=TRUE}
sapply(labwide, class) # all measurements are character!
startpos <- which(colnames(labwide) == "ACA")
labwide2 <- data.frame(labwide[,1:(startpos-1)], data.matrix(labwide[,startpos:ncol(labwide)]))
which(is.na(labwide2), arr.ind=T)[,2]

## impute low measurements
labwide[,14] <- gsub("<", "", labwide[,14])
labwide[,16] <- gsub("<", "", labwide[,16])

## these column is all NA
labwide <- labwide[,-17]
labwide <- data.frame(labwide[,1:5], data.matrix(labwide[,6:35]))
```


# Simple statistics with R

## Descriptive statistics

`tapply(x, groups, func)` applies a function `func` to some data `x`
grouped by `groups`.

```{r}
mean(labwide$NEUT)
sd(labwide$NEUT)

tapply(labwide$NEUT, labwide$ARM, mean)
tapply(labwide$NEUT, labwide$Timepoint, mean)
tapply(labwide$NEUT, 
  paste(labwide$ARM, labwide$Timepoint, sep="."), mean)
```

## Simple t.test

We define logical vectors to help us select the desired data.

```{r,eval=TRUE}
fluad    <- labwide$ARM == "FLUAD"
agrippal <- labwide$ARM == "AGRIPPAL"

d0 <- labwide$Timepoint == "D0"
d1 <- labwide$Timepoint == "D1"
```

## Simple t.test

Paired or not paired?

```{r,eval=TRUE}
tst <- "NEUT" # lymphocyte count
x <- labwide[ ,tst]
t.test(x[d0 & fluad], x[d1 & fluad])
t.test(x[d0 & fluad], x[d1 & fluad], paired=TRUE)
```

## Broom: cleaning up data

`tidy()` cleans up messy results of various standard statistical tests and
formats them into a nice, clean, TIDY data frame (or, rather, a tibble).

```{r,eval=TRUE,results="markdown"}
library(broom)
tidy(t.test(x[d0 & fluad], x[d1 & fluad], paired=TRUE))
```

## Caveat: paired data

We must make sure that all the data points are paired!

## Excercise 4.1

 * Run t-test for CRP (C-reactive protein), LYM (lymphocytes)
 * `wilcox.test()` is the U test / Mann Whitney test / Wilcoxon test. Try it. Are the p-values different?
 * use `tidy()` to clean up data
 * save the results for CRP and LYM in the data frames (with help of
   `tidy()`).
 * How can you combine two data frames (or tibbles, or matrices) row-wise?
   Look up the `rbind()` function. Create a single data frame with results
   for the CRP and LYM.
 * Adjust the p-values for multiple testing; create a q-value column using
   the function `p.adjust()`. What is the default method for correction for
   multiple testing?


## Simple basic plots (demonstration)

We have two main factors: ARM (the group) and Timepoint (before or 1 day
after vaccination). Therefore, we should plot accordingly.

```{r}
labwide$armcd <- gsub("(.).*", "\\1", labwide$ARM)
labwide$group <- paste(labwide$armcd, labwide$Timepoint, sep=".")

boxplot(NEUT ~ group, data=labwide)
```

## Simple basic plots (demonstration)

```{r,eval=TRUE,echo=FALSE}
labwide$armcd <- gsub("(.).*", "\\1", labwide$ARM)
labwide$group <- paste(labwide$armcd, labwide$Timepoint, sep=".")

boxplot(NEUT ~ group, data=labwide)
```

## Simple basic plots (demonstration)

```{r,eval=TRUE}
library(beeswarm)
beeswarm(NEUT ~ group, data=labwide)
```

## Excercise 4.2

 * Create box plots for selected variables

## ggplot2 vs basic R plots


Basic R plots:

 * super simple for a beginner
 * messy if you try to make it nice
 * you can do anything
 * some tools only produce basic R
 * SUPER fast

ggplot2:

 * produces nice and complex graphics with less effort
 * requires a data frame
 * more uniform
 * very different syntax
 * some things really hard to achieve



## Plot for pairwise data

```{r,eval=TRUE,fig.width=10,fig.height=4.5}
library(ggplot2)
ggplot(labwide, aes(x=Timepoint, y=NEUT, group=USUBJID, color=ARM)) + geom_line() + geom_point()
```

## Making it nicer

```{r,eval=TRUE,fig.width=10,fig.height=4.5}
ggplot(labwide, aes(x=Timepoint, y=NEUT, group=USUBJID)) + geom_line() + geom_point() + 
  facet_grid(. ~ ARM)
```

## Making it nicer

```{r, eval=FALSE}
ggplot(labwide, aes(x=Timepoint, y=NEUT, group=USUBJID)) + 
  geom_line(color="grey") + 
  geom_point() + 
  facet_grid(. ~ ARM) +
  xlab("Day") +
  ylab("Neutrophiles") +
  theme_bw() +
  ggtitle("Change in neutrophile count in different study arms")
```


## Making it nicer

```{r, eval=TRUE,echo=FALSE,fig.width=10,fig.height=5}
ggplot(labwide, aes(x=Timepoint, y=NEUT, group=USUBJID)) + 
  geom_line(color="grey") + 
  geom_point() + 
  facet_grid(. ~ ARM) +
  xlab("Day") +
  ylab("Neutrophiles") +
  theme_bw() +
  ggtitle("Change in neutrophile count in different study arms")
```

# SD, SEM and different plot types

## SD vs SEM


```{r,eval=TRUE}

## generate mock data sets with different sample sizes
ns <- c(10, 50, 100, 500)
data <- rnorm(sum(ns))
## repeat "a" 10 times, "b" 50 times, etc.
labs <- unlist(lapply(1:length(ns), 
  function(i) rep(letters[i], ns[i])))

## calculate means, SD and SEM
means <- tapply(data, labs, mean)
sds <- tapply(data, labs, sd)
ses <- sds/sqrt(ns)
```


## SD vs SEM (cont.)

```{r,echo=FALSE,eval=TRUE,fig.width=7,fig.height=5}
x <- (1:length(ns))-.3 # for plotting

plot(NULL, xlim=c(.5, length(ns) + .5), ylim=c(-5, 5), bty="n", xlab="", ylab="")
## means
abline(h=0, col="grey")
abline(h=c(-1,1), col="grey", lty=2)
segments(x, tapply(data, labs, mean), x+.6, tapply(data, labs, mean), lwd=2)

rect(x + .1, means-sds, x + .5, means + sds, col="#00999933")
rect(x, means-ses, x + .6, means + ses, col="#00FFFF33")
beeswarm(data ~ labs, pch=19, col="#33333333", add=TRUE)
```


```{r echo=FALSE,eval=TRUE}
ebar <- function(x, y, sd, width=1, ...) {
  w <- width/2

  segments(x, y, x, y + sd, ...)
  segments(x - w, y + sd, x + w, y + sd, ...)
}
```


## SD vs SEM (cont.)


```{r eval=TRUE,echo=FALSE}
set.seed(121234)
data <- c(rnorm(100) + 1.6, rnorm(100) + 2)
labs <- rep(letters[1:2], each=100)
```

p < `r format.pval(t.test(data ~ labs)$p.value, digits=2)`

```{r eval=TRUE,echo=FALSE,fig.width=3,fig.height=5}
## calculate the means and SEMs
means <- tapply(data, labs, mean)
sems <- tapply(data, labs, sd)/sqrt(100)
bp <- barplot(means, ylim=c(0, 2.5), space=.9)
ebar(bp[,1], means, sems, width=.6)
```

## SD vs SEM (cont.)

```{r eval=TRUE,echo=FALSE,fig.width=8,fig.height=5}

layout(t(c(1,2)), widths=c(1,4))
## calculate the means and SEMs
bp <- barplot(means, ylim=c(0, 2.5), space=.1)
ebar(bp[,1], means, sems, width=.6)
bp <- barplot(means, ylim=c(0, 2.5), space=.6)
ebar(bp[,1], means, sems, width=.3)
```


## SD vs SEM (cont.)


```{r eval=TRUE,echo=FALSE,fig.width=8,fig.height=5}
par(mfrow=c(1,2))
bp <- barplot(means, ylim=c(0, 2.5), space=.9)
ebar(bp[,1], means, sems, width=.5)
boxplot(data ~ labs, frame=FALSE, notch=TRUE)
```


## SD vs SEM (cont.)

```{r eval=TRUE,echo=FALSE,fig.width=8,fig.height=5}
par(mfrow=c(1,2))
bp <- barplot(means, ylim=c(0, 2.5), space=.9)
ebar(bp[,1], means, sems, width=.5)
beeswarm(data ~ labs, bty="n")
```

## SD vs SEM (cont.)

```{r eval=TRUE,echo=FALSE,fig.width=8,fig.height=5}
par(mfrow=c(1,2))
bp <- barplot(means, ylim=c(0, 2.5), space=.9)
ebar(bp[,1], means, sems, width=.5)
vioplot(data ~ labs, col="#33993333", frame.plot=F)
```



# Multivariate data

## PCA

```{r}
data(iris)
theme_set(theme_bw())
pca <- prcomp(iris[,1:4], scale.=TRUE)
df <- data.frame(pca$x, species=iris$Species)
ggplot(df, aes(x=PC1, y=PC2, color=species)) + geom_point()
```

## PCA (cont.)

```{r,eval=TRUE,echo=FALSE}
data(iris)
theme_set(theme_bw())
pca <- prcomp(iris[,1:4], scale.=TRUE)
df <- data.frame(pca$x, species=iris$Species)
ggplot(df, aes(x=PC1, y=PC2, color=species)) + geom_point()
```



## Putting two plots on one graphics

```{r}
library(cowplot)
pca12 <- ggplot(df, aes(x=PC1, y=PC2, color=species)) + geom_point()
pca34 <- ggplot(df, aes(x=PC3, y=PC4, color=species)) + geom_point()
plot_grid(pca12, pca34)
```

## Putting two plots on one graphics (cont.)

```{r,eval=TRUE,echo=FALSE,fig.width=8,fig.height=4}
library(cowplot)
pca12 <- ggplot(df, aes(x=PC1, y=PC2, color=species)) + geom_point()
pca34 <- ggplot(df, aes(x=PC3, y=PC4, color=species)) + geom_point()
plot_grid(pca12, pca34)
```

## Guided Exercise 

 * Create a subset of `labwide` containing only data for D1 and either
   Fluad or placebo. Call it `labw_sel`.
 * Create a data set from labwide: `labw_mtx <- select(labw_sel, ACA:WBC)`
 * Compute and display a PCA for the `labw_mtx` data set. Which components
   appear to be related to the different sample groups? 
 * Take a look at `pca$rotation`. Order it by the absolute value for the
   component in which you can see the difference between group. Take a look
   at the rownames of this sorted matrix. See anything?

## Playing with PCA: Gene expression

(demonstration)

## The mtcars data set – correlations & co.


```{r}
data(mtcars)
pairs(mtcars[,1:5])
cor(mtcars$hp, mtcars$mpg)
cor.test(mtcars$hp, mtcars$mpg)
cor.test(mtcars$hp, mtcars$mpg, method="spearman")
```

# Linear regression

## Simple linear regression

```{r}
mod <- lm(mpg ~ hp + disp)
summary(mod)
tidy(mod)
```



## Calculating linear regression

```{r,eval=TRUE}
mod1 <- lm(mpg ~ hp, data=mtcars)
summary(mod1)
mod2 <- lm(mpg ~ hp + disp, data=mtcars)
summary(mod2)
```

## Plotting linear regression: basic

Plotting mod2 would be less trivial, since we only show one predictor
variable on the plot, but the model depends on two of them.

```{r eval=TRUE,fig.height=3,fig.width=4}
plot(mtcars$hp, mtcars$mpg)
abline(mod1)
```

## Comparing models 

```{r,eval=TRUE}
mod1 <- lm(mpg ~ hp, data=mtcars)
summary(mod1)
mod2 <- lm(mpg ~ hp + disp, data=mtcars)
summary(mod2)
anova(mod1, mod2)
mod.l <- lm(mpg ~ log(hp), data=mtcars)
BIC(mod1, mod2, mod.l)
```


## Plotting linear regression

Confidence intervals tell us how well we have estimated the relationship.
Prediction intervals tell us how well we can predict new data points using
this model.

```{r}
mod <- lm(mpg ~ log(hp), data=mtcars)
xnew <- 50:350
plot(mtcars$hp, mtcars$mpg, log="x", xlab="HP",
  ylab="MPG", bty="n")
ci <- predict(mod, newdata=data.frame(hp=xnew), interval="conf")
lines(xnew, ci[,1], lwd=2) # fit
lines(xnew, ci[,2]) # lower CI
lines(xnew, ci[,3]) # upper CI
pr <- predict(mod, newdata=data.frame(hp=xnew), interval="pred")
lines(xnew, pr[,2], lty=2) # lower prediction
lines(xnew, pr[,3], lty=2) # upper prediction
```


## Plotting linear regression (cont.)

```{r,eval=TRUE,echo=FALSE,fig.width=6,fig.height=5}
mod <- lm(mpg ~ log(hp), data=mtcars)
xnew <- 50:350
plot(mtcars$hp, mtcars$mpg, log="x", xlab="HP",
  ylab="MPG", bty="n")
ci <- predict(mod, newdata=data.frame(hp=xnew), interval="conf")
lines(xnew, ci[,1], lwd=2) # fit
lines(xnew, ci[,2]) # lower CI
lines(xnew, ci[,3]) # upper CI
pr <- predict(mod, newdata=data.frame(hp=xnew), interval="pred")
lines(xnew, pr[,2], lty=2) # lower prediction
lines(xnew, pr[,3], lty=2) # upper prediction
```


## Plotting linear regression cont.

```{r}
plot(NULL, xlim=c(50,350), ylim=c(5,45), log="x", xlab="HP",
  ylab="MPG", bty="n")
x2 <- c(xnew, rev(xnew))
polygon(x2, c(pr[,2], rev(pr[,3])), col="#FF330033", border=NA)
polygon(x2, c(ci[,2], rev(ci[,3])), col="#FF330033", border=NA)
lines(xnew, ci[,1], col="#FF3300", lwd=2) # fit
points(mtcars$hp, mtcars$mpg, pch=19, cex=1.3, col="#99110033")
```


## Plotting linear regression cont.

```{r,echo=FALSE,eval=TRUE,fig.width=7,fig.height=5}
plot(NULL, xlim=c(50,350), ylim=c(5,45), log="x", xlab="HP",
  ylab="MPG", bty="n")
x2 <- c(xnew, rev(xnew))
polygon(x2, c(pr[,2], rev(pr[,3])), col="#FF330033", border=NA)
polygon(x2, c(ci[,2], rev(ci[,3])), col="#FF330033", border=NA)
lines(xnew, ci[,1], col="#FF3300", lwd=2) # fit
points(mtcars$hp, mtcars$mpg, pch=19, cex=1.3, col="#991100")
```


# Heatmaps

## loading data

```{r eval=TRUE}
genes <- read_xlsx("Datasets/expression_data_vaccination_example.xlsx", 
  sheet=2)
e <- read_xlsx("Datasets/expression_data_vaccination_example.xlsx", 
  sheet=3)
t <- read_xlsx("Datasets/expression_data_vaccination_example.xlsx", 
  sheet=1)
res <- read.csv("Datasets/transcriptomics_results.csv")

## res and genes are not identical!
com <- intersect(genes$ProbeName, res$ProbeName)
e <- data.matrix(e[ match(com, genes$ProbeName), ])
genes <- genes[ match(com, genes$ProbeName), ]
rownames(e) <- genes$GeneName
res <- res[ match(com, res$ProbeName), ]
all(res$ProbeName == genes$ProbeName)
```


## Selecting genes to plot on a heatmap

```{r eval=TRUE}
n <- 25 # top 50
byqval <- order(res$qval.F.D1)
sel <- byqval[1:n]

downreg <- which(res$logFC.F.D1 < 0)
downreg <- byqval[ byqval %in% downreg ][1:n]

sel <- c(sel, downreg)


## ordering and selecting columns
group <- paste0(t$ARM, ".", t$Timepoint)
csel <- order(group)
## FLUAD only
csel <- csel[ csel %in% which(t$ARM == "FLUAD") ] 
```

## Plotting the heatmap

```{r}
library(gplots)
mtx <- t(e[sel, csel])

## scale manually
mtx <- scale(mtx)

## palette
pal <- colorRampPalette(c("cyan", "black", "purple"))
heatmap.2(mtx, trace="n", scale="n", dendrogram="c", 
  Rowv=FALSE, col=pal,
  breaks=seq(-2, 2, length.out=15) )
```


## 

```{r,eval=TRUE,echo=FALSE,fig.width=8,fig.height=6}
library(gplots)
mtx <- t(e[sel, csel])

## scale manually
mtx <- scale(mtx)

## palette
pal <- colorRampPalette(c("cyan", "black", "purple"))
heatmap.2(mtx, trace="n", scale="n", dendrogram="c", 
  Rowv=FALSE, col=pal,
  breaks=seq(-2, 2, length.out=15) )
```



